"""Persistence node for saving extracted state to database.

This node processes extraction results and persists them using
the appropriate managers. Supports both legacy extraction-based
persistence and manifest-based persistence from GMResponse.
"""

from typing import Any, Callable, Coroutine

from sqlalchemy.orm import Session

from src.agents.state import GameState
from src.database.models.enums import EntityType, GoalPriority, GoalStatus, GoalType
from src.database.models.session import GameSession, Turn
from src.managers.entity_manager import EntityManager
from src.managers.fact_manager import FactManager
from src.managers.goal_manager import GoalManager
from src.managers.relationship_manager import RelationshipManager


async def persistence_node(state: GameState) -> dict[str, Any]:
    """Persist extracted state to database.

    This is the default node function that expects _db and _game_session
    to be present in state.

    Args:
        state: Current game state with _db and _game_session.

    Returns:
        Empty dict (persistence is a side effect).
    """
    db: Session = state.get("_db")  # type: ignore
    game_session: GameSession = state.get("_game_session")  # type: ignore

    if db is None or game_session is None:
        return {
            "errors": ["Missing database session or game session in state"],
        }

    return await _persist_state(db, game_session, state)


def create_persistence_node(
    db: Session,
    game_session: GameSession,
) -> Callable[[GameState], Coroutine[Any, Any, dict[str, Any]]]:
    """Create a persistence node with bound dependencies.

    Args:
        db: Database session.
        game_session: Current game session.

    Returns:
        Async node function that persists state.
    """

    async def node(state: GameState) -> dict[str, Any]:
        """Persist extracted state to database.

        Args:
            state: Current game state.

        Returns:
            Empty dict (persistence is a side effect).
        """
        return await _persist_state(db, game_session, state)

    return node


async def _persist_state(
    db: Session,
    game_session: GameSession,
    state: GameState,
) -> dict[str, Any]:
    """Internal helper to persist state.

    Supports two modes:
    1. Manifest-based: If state contains 'gm_manifest', uses structured manifest data
    2. Extraction-based: Falls back to legacy extracted_entities/extracted_facts

    Args:
        db: Database session.
        game_session: Current game session.
        state: Current game state with extractions or manifest.

    Returns:
        Empty dict or errors.
    """
    errors: list[str] = []

    # Initialize managers
    entity_manager = EntityManager(db, game_session)
    fact_manager = FactManager(db, game_session)
    relationship_manager = RelationshipManager(db, game_session)
    goal_manager = GoalManager(db, game_session)

    # Check if we have manifest-based data (from GMResponse structured output)
    manifest = state.get("gm_manifest")
    if manifest is not None:
        # Use manifest-based persistence
        errors.extend(
            _persist_from_manifest(
                entity_manager,
                fact_manager,
                relationship_manager,
                goal_manager,
                manifest,
                state.get("player_id"),
            )
        )
    else:
        # Use legacy extraction-based persistence
        # Get entity keys that were already fully generated by npc_generator
        generated_npc_keys = {
            npc.get("entity_key")
            for npc in state.get("generated_npcs", [])
            if npc.get("entity_key")
        }

        # Persist extracted entities (skip those already generated)
        for entity_data in state.get("extracted_entities", []):
            try:
                _persist_entity(entity_manager, entity_data, generated_npc_keys)
            except Exception as e:
                errors.append(f"Failed to persist entity: {e}")

        # Persist extracted facts
        for fact_data in state.get("extracted_facts", []):
            try:
                _persist_fact(fact_manager, fact_data)
            except Exception as e:
                errors.append(f"Failed to persist fact: {e}")

        # Persist relationship changes
        for change_data in state.get("relationship_changes", []):
            try:
                _persist_relationship_change(
                    entity_manager, relationship_manager, change_data, state.get("player_id")
                )
            except Exception as e:
                errors.append(f"Failed to persist relationship change: {e}")

    # Create turn record
    try:
        _create_turn_record(db, game_session, state)
    except Exception as e:
        errors.append(f"Failed to create turn record: {e}")

    if errors:
        return {"errors": errors}
    return {}


def _persist_entity(
    entity_manager: EntityManager,
    entity_data: dict[str, Any],
    generated_npc_keys: set[str] | None = None,
) -> None:
    """Persist a single extracted entity.

    Args:
        entity_manager: EntityManager instance.
        entity_data: Extracted entity data.
        generated_npc_keys: Set of entity keys already generated by npc_generator.
    """
    entity_key = entity_data.get("entity_key")
    if not entity_key:
        return

    # Skip if already fully generated by npc_generator
    if generated_npc_keys and entity_key in generated_npc_keys:
        return  # Already created with full data

    # Check if entity already exists
    existing = entity_manager.get_entity(entity_key)
    if existing:
        return  # Don't create duplicate

    # Map string entity_type to enum
    entity_type_str = entity_data.get("entity_type", "npc")
    entity_type = EntityType.NPC
    if entity_type_str == "player":
        entity_type = EntityType.PLAYER
    elif entity_type_str == "monster":
        entity_type = EntityType.MONSTER
    elif entity_type_str == "object":
        entity_type = EntityType.OBJECT

    entity_manager.create_entity(
        entity_key=entity_key,
        display_name=entity_data.get("display_name", entity_key),
        entity_type=entity_type,
        description=entity_data.get("description"),
    )


def _persist_fact(
    fact_manager: FactManager,
    fact_data: dict[str, Any],
) -> None:
    """Persist a single extracted fact.

    Args:
        fact_manager: FactManager instance.
        fact_data: Extracted fact data.
    """
    subject = fact_data.get("subject")
    predicate = fact_data.get("predicate")
    value = fact_data.get("value")

    if not all([subject, predicate, value]):
        return

    fact_manager.record_fact(
        subject=subject,
        predicate=predicate,
        value=value,
        is_secret=fact_data.get("is_secret", False),
    )


def _persist_relationship_change(
    entity_manager: EntityManager,
    relationship_manager: RelationshipManager,
    change_data: dict[str, Any],
    player_id: int | None,
) -> None:
    """Persist a relationship change from legacy extraction.

    Args:
        entity_manager: EntityManager instance for entity lookup.
        relationship_manager: RelationshipManager instance.
        change_data: Relationship change data with entity_key, dimension, change.
        player_id: Player entity ID.
    """
    entity_key = change_data.get("entity_key")
    dimension = change_data.get("dimension")
    change = change_data.get("change", 0)
    reason = change_data.get("reason", "Interaction")

    if not entity_key or not dimension or not player_id:
        return

    # Look up entity by key
    entity = entity_manager.get_entity(entity_key)
    if not entity:
        return

    # Update the relationship between this entity and the player
    relationship_manager.update_attitude(
        from_id=entity.id,
        to_id=player_id,
        dimension=dimension,
        delta=change,
        reason=reason,
    )


def _create_turn_record(
    db: Session,
    game_session: GameSession,
    state: GameState,
) -> Turn | None:
    """Create or update a turn record for this interaction.

    If the turn was already saved by game.py (for immediate persistence),
    this updates it with extraction data. Otherwise creates a new record.

    Args:
        db: Database session.
        game_session: Current game session.
        state: Current game state.

    Returns:
        Turn record (created or updated), or None if update only.
    """
    turn_number = state.get("turn_number", game_session.total_turns + 1)

    # Check if turn already saved by game.py
    existing = (
        db.query(Turn)
        .filter(
            Turn.session_id == game_session.id,
            Turn.turn_number == turn_number,
        )
        .first()
    )

    if existing:
        # Update with extraction data (turn already has player_input and gm_response)
        if state.get("extracted_entities"):
            existing.entities_extracted = state.get("extracted_entities")
        if state.get("player_location"):
            existing.location_at_turn = state.get("player_location")
        return existing

    # Create new turn (fallback for non-game.py callers like tests)
    turn = Turn(
        session_id=game_session.id,
        turn_number=turn_number,
        player_input=state.get("player_input", ""),
        gm_response=state.get("gm_response", ""),
    )
    db.add(turn)
    db.flush()
    return turn


# =============================================================================
# Manifest-based Persistence (for GMResponse structured output)
# =============================================================================


def _persist_from_manifest(
    entity_manager: EntityManager,
    fact_manager: FactManager,
    relationship_manager: RelationshipManager,
    goal_manager: GoalManager,
    manifest: dict[str, Any],
    player_id: int | None,
) -> list[str]:
    """Persist state changes from a GMManifest.

    Processes all manifest sections: facts, relationships, goals.
    NPC/item creation is handled by GM tools during generation.

    Args:
        entity_manager: EntityManager instance.
        fact_manager: FactManager instance.
        relationship_manager: RelationshipManager instance.
        goal_manager: GoalManager instance.
        manifest: GMManifest data dict.
        player_id: Player entity ID.

    Returns:
        List of error messages (empty if successful).
    """
    errors: list[str] = []

    # Persist facts revealed
    for fact_data in manifest.get("facts_revealed", []):
        try:
            _persist_manifest_fact(fact_manager, fact_data)
        except Exception as e:
            errors.append(f"Failed to persist fact: {e}")

    # Persist relationship changes
    for change_data in manifest.get("relationship_changes", []):
        try:
            _persist_manifest_relationship(
                entity_manager, relationship_manager, change_data
            )
        except Exception as e:
            errors.append(f"Failed to persist relationship change: {e}")

    # Persist new goals
    for goal_data in manifest.get("goals_created", []):
        try:
            _persist_manifest_goal_creation(entity_manager, goal_manager, goal_data)
        except Exception as e:
            errors.append(f"Failed to create goal: {e}")

    # Process goal updates
    for update_data in manifest.get("goal_updates", []):
        try:
            _persist_manifest_goal_update(goal_manager, update_data)
        except Exception as e:
            errors.append(f"Failed to update goal: {e}")

    return errors


def _persist_manifest_fact(
    fact_manager: FactManager,
    fact_data: dict[str, Any],
) -> None:
    """Persist a fact from GMManifest.

    Args:
        fact_manager: FactManager instance.
        fact_data: FactRevealed dict from manifest.
    """
    subject = fact_data.get("subject")
    predicate = fact_data.get("predicate")
    value = fact_data.get("value")

    if not all([subject, predicate, value]):
        return

    # Infer subject_type from subject key pattern
    # entity keys typically have format like "merchant_bob", "player"
    # location keys might have format like "tavern", "market_square"
    subject_type = "entity"  # Default to entity

    fact_manager.record_fact(
        subject_type=subject_type,
        subject_key=subject,
        predicate=predicate,
        value=value,
        is_secret=fact_data.get("is_secret", False),
    )


def _persist_manifest_relationship(
    entity_manager: EntityManager,
    relationship_manager: RelationshipManager,
    change_data: dict[str, Any],
) -> None:
    """Persist a relationship change from GMManifest.

    Args:
        entity_manager: EntityManager instance.
        relationship_manager: RelationshipManager instance.
        change_data: RelationshipChange dict from manifest.
    """
    from src.database.models.enums import RelationshipDimension

    from_entity_key = change_data.get("from_entity")
    to_entity_key = change_data.get("to_entity")
    dimension_str = change_data.get("dimension")
    delta = change_data.get("delta", 0)
    reason = change_data.get("reason", "")

    if not from_entity_key or not to_entity_key or not dimension_str:
        return

    # Look up entity IDs
    from_entity = entity_manager.get_entity(from_entity_key)
    to_entity = entity_manager.get_entity(to_entity_key)

    if not from_entity or not to_entity:
        return

    # Convert dimension string to enum
    try:
        dimension = RelationshipDimension(dimension_str)
    except ValueError:
        return  # Invalid dimension, skip

    # Update relationship
    relationship_manager.update_attitude(
        from_id=from_entity.id,
        to_id=to_entity.id,
        dimension=dimension,
        delta=delta,
        reason=reason,
    )


def _persist_manifest_goal_creation(
    entity_manager: EntityManager,
    goal_manager: GoalManager,
    goal_data: dict[str, Any],
) -> None:
    """Persist a new goal from GMManifest.

    Args:
        entity_manager: EntityManager instance.
        goal_manager: GoalManager instance.
        goal_data: GoalCreation dict from manifest.
    """
    entity_key = goal_data.get("entity_key")
    if not entity_key:
        return

    # Look up entity ID
    entity = entity_manager.get_entity(entity_key)
    if not entity:
        return

    # Map string types to enums
    goal_type_str = goal_data.get("goal_type", "acquire")
    priority_str = goal_data.get("priority", "medium")

    try:
        goal_type = GoalType(goal_type_str)
    except ValueError:
        goal_type = GoalType.ACQUIRE

    try:
        priority = GoalPriority(priority_str)
    except ValueError:
        priority = GoalPriority.MEDIUM

    goal_manager.create_goal(
        entity_id=entity.id,
        goal_type=goal_type,
        target=goal_data.get("target", "unknown"),
        description=goal_data.get("description", ""),
        success_condition=goal_data.get("success_condition", "Goal achieved"),
        motivation=goal_data.get("motivation", []),
        triggered_by=goal_data.get("triggered_by"),
        priority=priority,
        strategies=goal_data.get("strategies", []),
        failure_condition=goal_data.get("failure_condition"),
        deadline_description=goal_data.get("deadline_description"),
    )


def _persist_manifest_goal_update(
    goal_manager: GoalManager,
    update_data: dict[str, Any],
) -> None:
    """Process a goal update from GMManifest.

    Args:
        goal_manager: GoalManager instance.
        update_data: GoalUpdate dict from manifest.
    """
    goal_key = update_data.get("goal_key")
    if not goal_key:
        return

    goal = goal_manager.get_goal_by_key(goal_key)
    if not goal:
        return

    # Handle status changes
    status = update_data.get("status")
    outcome = update_data.get("outcome", "")

    if status == "completed":
        goal_manager.complete_goal(goal.id, outcome)
    elif status == "failed":
        goal_manager.fail_goal(goal.id, outcome)
    elif status == "abandoned":
        goal_manager.abandon_goal(goal.id, outcome)
    elif status == "blocked":
        goal_manager.block_goal(goal.id, outcome)
    else:
        # Handle step advancement
        current_step = update_data.get("current_step")
        if current_step is not None and current_step > goal.current_step:
            # Advance to specified step
            while goal.current_step < current_step:
                advanced = goal.advance_step()
                if not advanced:
                    break
