"""Persistence node for saving extracted state to database.

This node processes extraction results and persists them using
the appropriate managers. Supports both legacy extraction-based
persistence and manifest-based persistence from GMResponse.
"""

from typing import Any, Callable, Coroutine

from sqlalchemy.orm import Session

from src.agents.state import GameState
from src.database.models.enums import EntityType, GoalPriority, GoalStatus, GoalType, ItemType
from src.database.models.session import GameSession, Turn
from src.managers.entity_manager import EntityManager
from src.managers.fact_manager import FactManager
from src.managers.goal_manager import GoalManager
from src.managers.item_manager import ItemManager
from src.managers.location_manager import LocationManager
from src.managers.relationship_manager import RelationshipManager


async def persistence_node(state: GameState) -> dict[str, Any]:
    """Persist extracted state to database.

    This is the default node function that expects _db and _game_session
    to be present in state.

    Args:
        state: Current game state with _db and _game_session.

    Returns:
        Empty dict (persistence is a side effect).
    """
    db: Session = state.get("_db")  # type: ignore
    game_session: GameSession = state.get("_game_session")  # type: ignore

    if db is None or game_session is None:
        return {
            "errors": ["Missing database session or game session in state"],
        }

    return await _persist_state(db, game_session, state)


def create_persistence_node(
    db: Session,
    game_session: GameSession,
) -> Callable[[GameState], Coroutine[Any, Any, dict[str, Any]]]:
    """Create a persistence node with bound dependencies.

    Args:
        db: Database session.
        game_session: Current game session.

    Returns:
        Async node function that persists state.
    """

    async def node(state: GameState) -> dict[str, Any]:
        """Persist extracted state to database.

        Args:
            state: Current game state.

        Returns:
            Empty dict (persistence is a side effect).
        """
        return await _persist_state(db, game_session, state)

    return node


async def _persist_state(
    db: Session,
    game_session: GameSession,
    state: GameState,
) -> dict[str, Any]:
    """Internal helper to persist state.

    Supports two modes:
    1. Manifest-based: If state contains 'gm_manifest', uses structured manifest data
    2. Extraction-based: Falls back to legacy extracted_entities/extracted_facts

    Args:
        db: Database session.
        game_session: Current game session.
        state: Current game state with extractions or manifest.

    Returns:
        Empty dict or errors.
    """
    errors: list[str] = []

    # Initialize managers
    entity_manager = EntityManager(db, game_session)
    fact_manager = FactManager(db, game_session)
    relationship_manager = RelationshipManager(db, game_session)
    goal_manager = GoalManager(db, game_session)
    item_manager = ItemManager(db, game_session)
    location_manager = LocationManager(db, game_session)

    # Check if we have manifest-based data (from GMResponse structured output)
    manifest = state.get("gm_manifest")
    if manifest is not None:
        # Use manifest-based persistence
        errors.extend(
            _persist_from_manifest(
                entity_manager,
                fact_manager,
                relationship_manager,
                goal_manager,
                manifest,
                state.get("player_id"),
            )
        )
    else:
        # Use legacy extraction-based persistence
        # Get entity keys that were already fully generated by npc_generator
        generated_npc_keys = {
            npc.get("entity_key")
            for npc in state.get("generated_npcs", [])
            if npc.get("entity_key")
        }

        # Persist extracted entities (skip those already generated)
        for entity_data in state.get("extracted_entities", []):
            try:
                _persist_entity(entity_manager, item_manager, entity_data, generated_npc_keys)
            except Exception as e:
                errors.append(f"Failed to persist entity: {e}")

        # Persist extracted facts
        for fact_data in state.get("extracted_facts", []):
            try:
                _persist_fact(fact_manager, fact_data)
            except Exception as e:
                errors.append(f"Failed to persist fact: {e}")

        # Persist relationship changes
        for change_data in state.get("relationship_changes", []):
            try:
                _persist_relationship_change(
                    entity_manager, relationship_manager, change_data, state.get("player_id")
                )
            except Exception as e:
                errors.append(f"Failed to persist relationship change: {e}")

        # Persist extracted items
        for item_data in state.get("extracted_items", []):
            try:
                _persist_item(
                    entity_manager, item_manager, item_data, state.get("player_id")
                )
            except Exception as e:
                errors.append(f"Failed to persist item: {e}")

        # Persist extracted locations
        for location_data in state.get("extracted_locations", []):
            try:
                _persist_location(location_manager, location_data)
            except Exception as e:
                errors.append(f"Failed to persist location: {e}")

    # Create turn record
    try:
        _create_turn_record(db, game_session, state)
    except Exception as e:
        errors.append(f"Failed to create turn record: {e}")

    if errors:
        return {"errors": errors}
    return {}


def _persist_entity(
    entity_manager: EntityManager,
    item_manager: ItemManager,
    entity_data: dict[str, Any],
    generated_npc_keys: set[str] | None = None,
) -> None:
    """Persist a single extracted entity with automatic body storage.

    Args:
        entity_manager: EntityManager instance.
        item_manager: ItemManager instance for body storage creation.
        entity_data: Extracted entity data.
        generated_npc_keys: Set of entity keys already generated by npc_generator.
    """
    entity_key = entity_data.get("entity_key")
    if not entity_key:
        return

    # Skip if already fully generated by npc_generator
    if generated_npc_keys and entity_key in generated_npc_keys:
        return  # Already created with full data

    # Check if entity already exists by key
    existing = entity_manager.get_entity(entity_key)
    if existing:
        return  # Don't create duplicate

    # Also check by display_name to catch duplicates with different keys
    # (e.g., "village_woman_elara" vs "elara" for same person)
    display_name = entity_data.get("display_name", entity_key)
    existing_by_name = entity_manager.get_entity_by_display_name(display_name)
    if existing_by_name:
        return  # Entity with same display name already exists

    # Map string entity_type to enum
    entity_type_str = entity_data.get("entity_type", "npc")
    entity_type = EntityType.NPC
    if entity_type_str == "player":
        entity_type = EntityType.PLAYER
    elif entity_type_str == "monster":
        entity_type = EntityType.MONSTER
    elif entity_type_str == "object":
        entity_type = EntityType.OBJECT

    entity = entity_manager.create_entity(
        entity_key=entity_key,
        display_name=entity_data.get("display_name", entity_key),
        entity_type=entity_type,
    )

    # Description field doesn't exist on Entity model - stored as fact instead
    if entity_data.get("description"):
        from src.managers.fact_manager import FactManager

        fact_manager = FactManager(entity_manager.db, entity_manager.game_session)
        fact_manager.record_fact(
            subject_type="entity",
            subject_key=entity_key,
            predicate="description",
            value=entity_data["description"],
        )

    # Auto-create body storage for the entity
    item_manager.get_or_create_body_storage(entity.id)


def _persist_fact(
    fact_manager: FactManager,
    fact_data: dict[str, Any],
) -> None:
    """Persist a single extracted fact.

    Args:
        fact_manager: FactManager instance.
        fact_data: Extracted fact data.
    """
    subject = fact_data.get("subject")
    predicate = fact_data.get("predicate")
    value = fact_data.get("value")

    if not all([subject, predicate, value]):
        return

    fact_manager.record_fact(
        subject_type="entity",  # Default to entity type
        subject_key=subject,
        predicate=predicate,
        value=value,
        is_secret=fact_data.get("is_secret", False),
    )


def _persist_relationship_change(
    entity_manager: EntityManager,
    relationship_manager: RelationshipManager,
    change_data: dict[str, Any],
    player_id: int | None,
) -> None:
    """Persist a relationship change from entity extraction.

    Supports both legacy format (entity_key, change) and new format (from_entity, to_entity, delta).

    Args:
        entity_manager: EntityManager instance for entity lookup.
        relationship_manager: RelationshipManager instance.
        change_data: Relationship change data.
        player_id: Player entity ID.
    """
    # Support both old format (entity_key) and new format (from_entity/to_entity)
    from_entity_key = change_data.get("from_entity") or change_data.get("entity_key")
    to_entity_key = change_data.get("to_entity")
    dimension = change_data.get("dimension")
    # Support both "delta" (new) and "change" (legacy)
    delta = change_data.get("delta") or change_data.get("change", 0)
    reason = change_data.get("reason", "Interaction")

    if not from_entity_key or not dimension:
        return

    # Look up from_entity by key
    from_entity = entity_manager.get_entity(from_entity_key)
    if not from_entity:
        return

    # Determine to_entity: use to_entity_key if provided, otherwise default to player
    if to_entity_key:
        # Handle "player" as a special key
        if to_entity_key == "player":
            to_id = player_id
        else:
            to_entity = entity_manager.get_entity(to_entity_key)
            to_id = to_entity.id if to_entity else None
    else:
        # Legacy format: relationship is always with player
        to_id = player_id

    if not to_id:
        return

    # Update the relationship
    relationship_manager.update_attitude(
        from_id=from_entity.id,
        to_id=to_id,
        dimension=dimension,
        delta=delta,
        reason=reason,
    )


def _persist_item(
    entity_manager: EntityManager,
    item_manager: ItemManager,
    item_data: dict[str, Any],
    player_id: int | None,
) -> None:
    """Persist a single extracted item.

    Args:
        entity_manager: EntityManager for looking up owner entities.
        item_manager: ItemManager instance.
        item_data: Extracted item data.
        player_id: Player entity ID.
    """
    item_key = item_data.get("item_key")
    action = item_data.get("action", "mentioned")

    if not item_key:
        return

    # Skip "mentioned" items - only persist actual state changes
    if action == "mentioned":
        return

    # Check if item already exists
    existing = item_manager.get_item(item_key)

    if action == "acquired" and existing is None:
        # Determine owner - use owner_key if provided, else player
        owner_id = player_id
        owner_key = item_data.get("owner_key")
        if owner_key:
            owner_entity = entity_manager.get_entity(owner_key)
            if owner_entity:
                owner_id = owner_entity.id

        # Map string item_type to enum
        item_type_str = item_data.get("item_type", "misc")
        try:
            item_type = ItemType(item_type_str)
        except ValueError:
            item_type = ItemType.MISC

        # Use create_container_item for containers to auto-create linked storage
        if item_type == ItemType.CONTAINER:
            item_manager.create_container_item(
                item_key=item_key,
                display_name=item_data.get("display_name", item_key),
                owner_id=owner_id,
                holder_id=owner_id,
                container_type=item_data.get("container_type", "container"),
                description=item_data.get("description"),
            )
        else:
            item_manager.create_item(
                item_key=item_key,
                display_name=item_data.get("display_name", item_key),
                item_type=item_type,
                owner_id=owner_id,
                holder_id=owner_id,  # Initially holder = owner
                description=item_data.get("description"),
            )

    elif action == "dropped" and existing:
        # Item dropped - clear holder
        existing.holder_id = None

    elif action == "transferred" and existing:
        # Transfer to new owner
        new_owner_key = item_data.get("owner_key")
        if new_owner_key:
            new_owner = entity_manager.get_entity(new_owner_key)
            if new_owner:
                existing.holder_id = new_owner.id


def _persist_location(
    location_manager: LocationManager,
    location_data: dict[str, Any],
) -> None:
    """Persist a single extracted location.

    Args:
        location_manager: LocationManager instance.
        location_data: Extracted location data.
    """
    location_key = location_data.get("location_key")
    if not location_key:
        return

    # Check if location already exists by key
    existing = location_manager.get_location(location_key)
    if existing:
        return  # Don't create duplicate

    # Also check by display_name to avoid duplicates with different keys
    display_name = location_data.get("display_name", location_key)
    existing_by_name = location_manager.get_location_by_display_name(display_name)
    if existing_by_name:
        return  # Location with same display name already exists

    location_manager.create_location(
        location_key=location_key,
        display_name=display_name,
        category=location_data.get("category", "interior"),
        description=location_data.get("description", ""),
        parent_key=location_data.get("parent_location_key"),
    )


def _create_turn_record(
    db: Session,
    game_session: GameSession,
    state: GameState,
) -> Turn | None:
    """Create or update a turn record for this interaction.

    If the turn was already saved by game.py (for immediate persistence),
    this updates it with extraction data. Otherwise creates a new record.

    Args:
        db: Database session.
        game_session: Current game session.
        state: Current game state.

    Returns:
        Turn record (created or updated), or None if update only.
    """
    turn_number = state.get("turn_number", game_session.total_turns + 1)

    # Check if turn already saved by game.py
    existing = (
        db.query(Turn)
        .filter(
            Turn.session_id == game_session.id,
            Turn.turn_number == turn_number,
        )
        .first()
    )

    if existing:
        # Update with extraction data (turn already has player_input and gm_response)
        # Always set entities_extracted to record that extraction ran
        # (even if empty list, indicates extraction completed)
        if "extracted_entities" in state:
            existing.entities_extracted = state.get("extracted_entities") or []
        if state.get("player_location"):
            existing.location_at_turn = state.get("player_location")
        return existing

    # Create new turn (fallback for non-game.py callers like tests)
    turn = Turn(
        session_id=game_session.id,
        turn_number=turn_number,
        player_input=state.get("player_input", ""),
        gm_response=state.get("gm_response", ""),
    )
    db.add(turn)
    db.flush()
    return turn


# =============================================================================
# Manifest-based Persistence (for GMResponse structured output)
# =============================================================================


def _persist_from_manifest(
    entity_manager: EntityManager,
    fact_manager: FactManager,
    relationship_manager: RelationshipManager,
    goal_manager: GoalManager,
    manifest: dict[str, Any],
    player_id: int | None,
) -> list[str]:
    """Persist state changes from a GMManifest.

    Processes all manifest sections: facts, relationships, goals.
    NPC/item creation is handled by GM tools during generation.

    Args:
        entity_manager: EntityManager instance.
        fact_manager: FactManager instance.
        relationship_manager: RelationshipManager instance.
        goal_manager: GoalManager instance.
        manifest: GMManifest data dict.
        player_id: Player entity ID.

    Returns:
        List of error messages (empty if successful).
    """
    errors: list[str] = []

    # Persist facts revealed
    for fact_data in manifest.get("facts_revealed", []):
        try:
            _persist_manifest_fact(fact_manager, fact_data)
        except Exception as e:
            errors.append(f"Failed to persist fact: {e}")

    # Persist relationship changes
    for change_data in manifest.get("relationship_changes", []):
        try:
            _persist_manifest_relationship(
                entity_manager, relationship_manager, change_data
            )
        except Exception as e:
            errors.append(f"Failed to persist relationship change: {e}")

    # Persist new goals
    for goal_data in manifest.get("goals_created", []):
        try:
            _persist_manifest_goal_creation(entity_manager, goal_manager, goal_data)
        except Exception as e:
            errors.append(f"Failed to create goal: {e}")

    # Process goal updates
    for update_data in manifest.get("goal_updates", []):
        try:
            _persist_manifest_goal_update(goal_manager, update_data)
        except Exception as e:
            errors.append(f"Failed to update goal: {e}")

    return errors


def _persist_manifest_fact(
    fact_manager: FactManager,
    fact_data: dict[str, Any],
) -> None:
    """Persist a fact from GMManifest.

    Args:
        fact_manager: FactManager instance.
        fact_data: FactRevealed dict from manifest.
    """
    subject = fact_data.get("subject")
    predicate = fact_data.get("predicate")
    value = fact_data.get("value")

    if not all([subject, predicate, value]):
        return

    # Infer subject_type from subject key pattern
    # entity keys typically have format like "merchant_bob", "player"
    # location keys might have format like "tavern", "market_square"
    subject_type = "entity"  # Default to entity

    fact_manager.record_fact(
        subject_type=subject_type,
        subject_key=subject,
        predicate=predicate,
        value=value,
        is_secret=fact_data.get("is_secret", False),
    )


def _persist_manifest_relationship(
    entity_manager: EntityManager,
    relationship_manager: RelationshipManager,
    change_data: dict[str, Any],
) -> None:
    """Persist a relationship change from GMManifest.

    Args:
        entity_manager: EntityManager instance.
        relationship_manager: RelationshipManager instance.
        change_data: RelationshipChange dict from manifest.
    """
    from src.database.models.enums import RelationshipDimension

    from_entity_key = change_data.get("from_entity")
    to_entity_key = change_data.get("to_entity")
    dimension_str = change_data.get("dimension")
    delta = change_data.get("delta", 0)
    reason = change_data.get("reason", "")

    if not from_entity_key or not to_entity_key or not dimension_str:
        return

    # Look up entity IDs
    from_entity = entity_manager.get_entity(from_entity_key)
    to_entity = entity_manager.get_entity(to_entity_key)

    if not from_entity or not to_entity:
        return

    # Convert dimension string to enum
    try:
        dimension = RelationshipDimension(dimension_str)
    except ValueError:
        return  # Invalid dimension, skip

    # Update relationship
    relationship_manager.update_attitude(
        from_id=from_entity.id,
        to_id=to_entity.id,
        dimension=dimension,
        delta=delta,
        reason=reason,
    )


def _persist_manifest_goal_creation(
    entity_manager: EntityManager,
    goal_manager: GoalManager,
    goal_data: dict[str, Any],
) -> None:
    """Persist a new goal from GMManifest.

    Args:
        entity_manager: EntityManager instance.
        goal_manager: GoalManager instance.
        goal_data: GoalCreation dict from manifest.
    """
    entity_key = goal_data.get("entity_key")
    if not entity_key:
        return

    # Look up entity ID
    entity = entity_manager.get_entity(entity_key)
    if not entity:
        return

    # Map string types to enums
    goal_type_str = goal_data.get("goal_type", "acquire")
    priority_str = goal_data.get("priority", "medium")

    try:
        goal_type = GoalType(goal_type_str)
    except ValueError:
        goal_type = GoalType.ACQUIRE

    try:
        priority = GoalPriority(priority_str)
    except ValueError:
        priority = GoalPriority.MEDIUM

    goal_manager.create_goal(
        entity_id=entity.id,
        goal_type=goal_type,
        target=goal_data.get("target", "unknown"),
        description=goal_data.get("description", ""),
        success_condition=goal_data.get("success_condition", "Goal achieved"),
        motivation=goal_data.get("motivation", []),
        triggered_by=goal_data.get("triggered_by"),
        priority=priority,
        strategies=goal_data.get("strategies", []),
        failure_condition=goal_data.get("failure_condition"),
        deadline_description=goal_data.get("deadline_description"),
    )


def _persist_manifest_goal_update(
    goal_manager: GoalManager,
    update_data: dict[str, Any],
) -> None:
    """Process a goal update from GMManifest.

    Args:
        goal_manager: GoalManager instance.
        update_data: GoalUpdate dict from manifest.
    """
    goal_key = update_data.get("goal_key")
    if not goal_key:
        return

    goal = goal_manager.get_goal_by_key(goal_key)
    if not goal:
        return

    # Handle status changes
    status = update_data.get("status")
    outcome = update_data.get("outcome", "")

    if status == "completed":
        goal_manager.complete_goal(goal.id, outcome)
    elif status == "failed":
        goal_manager.fail_goal(goal.id, outcome)
    elif status == "abandoned":
        goal_manager.abandon_goal(goal.id, outcome)
    elif status == "blocked":
        goal_manager.block_goal(goal.id, outcome)
    else:
        # Handle step advancement
        current_step = update_data.get("current_step")
        if current_step is not None and current_step > goal.current_step:
            # Advance to specified step
            while goal.current_step < current_step:
                advanced = goal.advance_step()
                if not advanced:
                    break
