"""GameState TypedDict for LangGraph agent orchestration.

This module defines the central state schema that flows through all agent nodes.
State is passed between nodes and accumulated via reducer functions.
"""

from typing import Annotated, Any, Literal, TYPE_CHECKING, TypedDict

from operator import add

if TYPE_CHECKING:
    from src.parser.action_types import Action
    from src.validators.action_validator import ValidationResult
    from src.executor.action_executor import TurnResult


# Agent names for routing
AgentName = Literal[
    "context_compiler",
    "game_master",
    "entity_extractor",
    "npc_generator",
    "combat_resolver",
    "world_simulator",
    "persistence",
    "end",
]


class GameState(TypedDict, total=False):
    """Central state for LangGraph game orchestration.

    All fields are optional (total=False) to allow partial updates.
    Fields with Annotated[list, add] use reducers to accumulate values.

    Attributes:
        session_id: Database session ID for scoping all queries.
        player_id: Player entity ID.
        player_location: Current location key.
        player_input: Raw input from player this turn.
        gm_response: Generated narrative response.
        scene_context: Compiled scene context for GM prompt.
        next_agent: Which agent to route to next.
        time_advance_minutes: How much game time to advance.
        location_changed: Whether player moved locations.
        combat_active: Whether combat is in progress.
        combat_state: Combat encounter state (participants, initiative, etc.).
        extracted_entities: Entities extracted from GM response (legacy flow).
        extracted_facts: Facts extracted from GM response (legacy flow).
        extracted_items: Items extracted from GM response (legacy flow).
        extracted_locations: Locations extracted from GM response (legacy flow).
        relationship_changes: Relationship changes from GM response (legacy flow).
        appointments: Appointments/tasks extracted (legacy flow).
        generated_npcs: NPCs that were fully generated by npc_generator.
        gm_manifest: Structured manifest from GMResponse (if using structured output).
        simulation_result: Results from world simulation.
        skill_checks: Skill check results for interactive dice display.
        turn_number: Current turn number.
        errors: Accumulated error messages.

        # System-Authority Architecture fields (new flow)
        parsed_actions: List of parsed actions from player input.
        ambient_flavor: Non-mechanical flavor from player input (e.g., "nervously").
        validation_results: Results of validating each parsed action.
        complication: Optional complication generated by oracle.
        turn_result: Combined result of executing all validated actions.
    """

    # Session context (set once at turn start)
    session_id: int
    player_id: int
    player_location: str

    # Turn input/output
    player_input: str
    gm_response: str | None
    scene_context: str

    # Routing control
    next_agent: AgentName

    # Triggers for conditional routing
    time_advance_minutes: int
    location_changed: bool
    previous_location: str | None
    combat_active: bool
    combat_state: dict[str, Any] | None

    # Extraction results (accumulated via reducers)
    # Used by legacy extraction-based flow
    extracted_entities: Annotated[list[dict[str, Any]], add]
    extracted_facts: Annotated[list[dict[str, Any]], add]
    extracted_items: Annotated[list[dict[str, Any]], add]
    extracted_locations: Annotated[list[dict[str, Any]], add]
    relationship_changes: Annotated[list[dict[str, Any]], add]
    appointments: Annotated[list[dict[str, Any]], add]

    # NPC generation results
    generated_npcs: Annotated[list[dict[str, Any]], add]

    # Manifest-based state changes (for GMResponse structured output)
    # If set, persistence node uses this instead of extracted_* fields
    gm_manifest: dict[str, Any] | None

    # World simulation results
    simulation_result: dict[str, Any] | None

    # Skill checks (for interactive dice display)
    skill_checks: list[dict[str, Any]] | None

    # Metadata
    turn_number: int
    errors: Annotated[list[str], add]

    # System-Authority Architecture fields (new flow)
    # These fields are used by the new mechanical validation pipeline
    parsed_actions: list[dict[str, Any]] | None  # List of parsed Action dicts
    ambient_flavor: str | None  # Non-mechanical flavor (e.g., "nervously")
    validation_results: list[dict[str, Any]] | None  # ValidationResult dicts
    dynamic_plans: dict[str, Any] | None  # Plans for CUSTOM actions from dynamic_planner_node
    complication: dict[str, Any] | None  # Complication dict from oracle
    turn_result: dict[str, Any] | None  # TurnResult dict with execution results
    is_scene_request: bool  # Whether this is a scene intro request (skip action processing)
    scene_request_type: str | None  # Type of scene request ("intro", "description")

    # World generation fields (autonomous item spawning)
    spawned_items: list[dict[str, Any]] | None  # Items created this turn via SPAWN_ITEM
    deferred_items: list[dict[str, Any]] | None  # Items for on-demand spawning (from INFO mode)

    # Narrative validation fields
    narrative_retry_count: int  # Counter for re-narration attempts (max 2)
    narrative_validation_result: dict[str, Any] | None  # Validation outcome
    narrative_constraints: str | None  # Additional constraints for retry narration

    # Response mode routing fields
    response_mode: str | None  # "info" (skip narrator) or "narrate" (full prose)
    narrative_style: str | None  # "observe", "action", "dialogue", "combat", "emote"

    # Chained subturn fields (multi-action processing)
    chained_turn_result: dict[str, Any] | None  # ChainedTurnResult dict from subturn processor
    continuation_status: str | None  # "continue", "offer_choice", "abandon"
    queued_actions: list[dict[str, Any]] | None  # Remaining actions for player choice
    is_continuation: bool  # Whether this turn resumes queued actions
    continuation_prompt: str | None  # Question to ask player (e.g., "Continue to the well?")

    # Scene-First Architecture fields (new world-building flow)
    # These fields are used by the scene-first pipeline that builds the world BEFORE narrating
    world_update: dict[str, Any] | None  # WorldUpdate from world_mechanics_node
    scene_manifest: dict[str, Any] | None  # SceneManifest from scene_builder_node
    narrator_manifest: dict[str, Any] | None  # NarratorManifest for constrained narrator
    resolved_actions: list[dict[str, Any]] | None  # Actions with resolved entity references
    needs_clarification: bool  # Whether reference resolution needs player input
    clarification_prompt: str | None  # Question to ask player about ambiguous reference
    clarification_candidates: list[dict[str, Any]] | None  # Candidate entities for clarification
    just_entered_location: bool  # Whether player just entered this location (triggers scene building)

    # Runtime dependencies (injected by game loop, not persisted)
    _db: Any  # SQLAlchemy Session
    _game_session: Any  # GameSession model


# Fields that use the add reducer for accumulation
_REDUCER_FIELDS = {
    "extracted_entities",
    "extracted_facts",
    "extracted_items",
    "extracted_locations",
    "relationship_changes",
    "appointments",
    "generated_npcs",
    "errors",
}


def create_initial_state(
    session_id: int,
    player_id: int,
    player_location: str,
    player_input: str,
    turn_number: int = 1,
) -> GameState:
    """Create initial state for a new turn.

    Args:
        session_id: Database session ID.
        player_id: Player entity ID.
        player_location: Current location key.
        player_input: Player's input for this turn.
        turn_number: Turn number (default 1).

    Returns:
        Initial GameState with defaults set.
    """
    return GameState(
        # Session context
        session_id=session_id,
        player_id=player_id,
        player_location=player_location,
        # Turn I/O
        player_input=player_input,
        gm_response=None,
        scene_context="",
        # Routing
        next_agent="context_compiler",
        # Triggers
        time_advance_minutes=0,
        location_changed=False,
        previous_location=None,
        combat_active=False,
        combat_state=None,
        # Extraction results (empty lists)
        extracted_entities=[],
        extracted_facts=[],
        extracted_items=[],
        extracted_locations=[],
        relationship_changes=[],
        appointments=[],
        # NPC generation results
        generated_npcs=[],
        # Simulation
        simulation_result=None,
        # System-Authority Architecture (new flow)
        parsed_actions=None,
        ambient_flavor=None,
        validation_results=None,
        dynamic_plans=None,
        complication=None,
        turn_result=None,
        # World generation
        spawned_items=None,
        deferred_items=None,
        # Narrative validation
        narrative_retry_count=0,
        narrative_validation_result=None,
        narrative_constraints=None,
        # Response mode routing
        response_mode=None,
        narrative_style=None,
        # Chained subturn fields
        chained_turn_result=None,
        continuation_status=None,
        queued_actions=None,
        is_continuation=False,
        continuation_prompt=None,
        # Scene-First Architecture fields
        world_update=None,
        scene_manifest=None,
        narrator_manifest=None,
        resolved_actions=None,
        needs_clarification=False,
        clarification_prompt=None,
        clarification_candidates=None,
        just_entered_location=False,
        # Metadata
        turn_number=turn_number,
        errors=[],
    )


def merge_state(
    original: GameState,
    updates: dict[str, Any],
) -> GameState:
    """Merge updates into state, respecting reducer fields.

    Non-reducer fields are overwritten. Reducer fields (lists) are
    accumulated by extending the original list.

    Args:
        original: Original state dictionary.
        updates: Updates to merge.

    Returns:
        New state with updates applied (original is not mutated).
    """
    # Start with a copy of original
    result: dict[str, Any] = dict(original)

    for key, value in updates.items():
        if key in _REDUCER_FIELDS and isinstance(value, list):
            # Accumulate list fields
            existing = result.get(key, [])
            if not isinstance(existing, list):
                existing = []
            result[key] = existing + value
        else:
            # Overwrite non-reducer fields
            result[key] = value

    return GameState(**result)
